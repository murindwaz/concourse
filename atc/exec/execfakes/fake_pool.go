// Code generated by counterfeiter. DO NOT EDIT.
package execfakes

import (
	"context"
	"sync"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/exec"
	"github.com/concourse/concourse/atc/runtime"
	"github.com/concourse/concourse/atc/worker"
)

type FakePool struct {
	FindOrSelectWorkerStub        func(context.Context, db.ContainerOwner, runtime.ContainerSpec, worker.Spec, worker.PlacementStrategy, worker.PoolCallback) (runtime.Worker, error)
	findOrSelectWorkerMutex       sync.RWMutex
	findOrSelectWorkerArgsForCall []struct {
		arg1 context.Context
		arg2 db.ContainerOwner
		arg3 runtime.ContainerSpec
		arg4 worker.Spec
		arg5 worker.PlacementStrategy
		arg6 worker.PoolCallback
	}
	findOrSelectWorkerReturns struct {
		result1 runtime.Worker
		result2 error
	}
	findOrSelectWorkerReturnsOnCall map[int]struct {
		result1 runtime.Worker
		result2 error
	}
	LocateVolumeStub        func(lager.Logger, int, string) (runtime.Volume, runtime.Worker, bool, error)
	locateVolumeMutex       sync.RWMutex
	locateVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}
	locateVolumeReturns struct {
		result1 runtime.Volume
		result2 runtime.Worker
		result3 bool
		result4 error
	}
	locateVolumeReturnsOnCall map[int]struct {
		result1 runtime.Volume
		result2 runtime.Worker
		result3 bool
		result4 error
	}
	ReleaseWorkerStub        func(lager.Logger, runtime.ContainerSpec, runtime.Worker, worker.PlacementStrategy)
	releaseWorkerMutex       sync.RWMutex
	releaseWorkerArgsForCall []struct {
		arg1 lager.Logger
		arg2 runtime.ContainerSpec
		arg3 runtime.Worker
		arg4 worker.PlacementStrategy
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePool) FindOrSelectWorker(arg1 context.Context, arg2 db.ContainerOwner, arg3 runtime.ContainerSpec, arg4 worker.Spec, arg5 worker.PlacementStrategy, arg6 worker.PoolCallback) (runtime.Worker, error) {
	fake.findOrSelectWorkerMutex.Lock()
	ret, specificReturn := fake.findOrSelectWorkerReturnsOnCall[len(fake.findOrSelectWorkerArgsForCall)]
	fake.findOrSelectWorkerArgsForCall = append(fake.findOrSelectWorkerArgsForCall, struct {
		arg1 context.Context
		arg2 db.ContainerOwner
		arg3 runtime.ContainerSpec
		arg4 worker.Spec
		arg5 worker.PlacementStrategy
		arg6 worker.PoolCallback
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.FindOrSelectWorkerStub
	fakeReturns := fake.findOrSelectWorkerReturns
	fake.recordInvocation("FindOrSelectWorker", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.findOrSelectWorkerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePool) FindOrSelectWorkerCallCount() int {
	fake.findOrSelectWorkerMutex.RLock()
	defer fake.findOrSelectWorkerMutex.RUnlock()
	return len(fake.findOrSelectWorkerArgsForCall)
}

func (fake *FakePool) FindOrSelectWorkerCalls(stub func(context.Context, db.ContainerOwner, runtime.ContainerSpec, worker.Spec, worker.PlacementStrategy, worker.PoolCallback) (runtime.Worker, error)) {
	fake.findOrSelectWorkerMutex.Lock()
	defer fake.findOrSelectWorkerMutex.Unlock()
	fake.FindOrSelectWorkerStub = stub
}

func (fake *FakePool) FindOrSelectWorkerArgsForCall(i int) (context.Context, db.ContainerOwner, runtime.ContainerSpec, worker.Spec, worker.PlacementStrategy, worker.PoolCallback) {
	fake.findOrSelectWorkerMutex.RLock()
	defer fake.findOrSelectWorkerMutex.RUnlock()
	argsForCall := fake.findOrSelectWorkerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePool) FindOrSelectWorkerReturns(result1 runtime.Worker, result2 error) {
	fake.findOrSelectWorkerMutex.Lock()
	defer fake.findOrSelectWorkerMutex.Unlock()
	fake.FindOrSelectWorkerStub = nil
	fake.findOrSelectWorkerReturns = struct {
		result1 runtime.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakePool) FindOrSelectWorkerReturnsOnCall(i int, result1 runtime.Worker, result2 error) {
	fake.findOrSelectWorkerMutex.Lock()
	defer fake.findOrSelectWorkerMutex.Unlock()
	fake.FindOrSelectWorkerStub = nil
	if fake.findOrSelectWorkerReturnsOnCall == nil {
		fake.findOrSelectWorkerReturnsOnCall = make(map[int]struct {
			result1 runtime.Worker
			result2 error
		})
	}
	fake.findOrSelectWorkerReturnsOnCall[i] = struct {
		result1 runtime.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakePool) LocateVolume(arg1 lager.Logger, arg2 int, arg3 string) (runtime.Volume, runtime.Worker, bool, error) {
	fake.locateVolumeMutex.Lock()
	ret, specificReturn := fake.locateVolumeReturnsOnCall[len(fake.locateVolumeArgsForCall)]
	fake.locateVolumeArgsForCall = append(fake.locateVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.LocateVolumeStub
	fakeReturns := fake.locateVolumeReturns
	fake.recordInvocation("LocateVolume", []interface{}{arg1, arg2, arg3})
	fake.locateVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakePool) LocateVolumeCallCount() int {
	fake.locateVolumeMutex.RLock()
	defer fake.locateVolumeMutex.RUnlock()
	return len(fake.locateVolumeArgsForCall)
}

func (fake *FakePool) LocateVolumeCalls(stub func(lager.Logger, int, string) (runtime.Volume, runtime.Worker, bool, error)) {
	fake.locateVolumeMutex.Lock()
	defer fake.locateVolumeMutex.Unlock()
	fake.LocateVolumeStub = stub
}

func (fake *FakePool) LocateVolumeArgsForCall(i int) (lager.Logger, int, string) {
	fake.locateVolumeMutex.RLock()
	defer fake.locateVolumeMutex.RUnlock()
	argsForCall := fake.locateVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePool) LocateVolumeReturns(result1 runtime.Volume, result2 runtime.Worker, result3 bool, result4 error) {
	fake.locateVolumeMutex.Lock()
	defer fake.locateVolumeMutex.Unlock()
	fake.LocateVolumeStub = nil
	fake.locateVolumeReturns = struct {
		result1 runtime.Volume
		result2 runtime.Worker
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePool) LocateVolumeReturnsOnCall(i int, result1 runtime.Volume, result2 runtime.Worker, result3 bool, result4 error) {
	fake.locateVolumeMutex.Lock()
	defer fake.locateVolumeMutex.Unlock()
	fake.LocateVolumeStub = nil
	if fake.locateVolumeReturnsOnCall == nil {
		fake.locateVolumeReturnsOnCall = make(map[int]struct {
			result1 runtime.Volume
			result2 runtime.Worker
			result3 bool
			result4 error
		})
	}
	fake.locateVolumeReturnsOnCall[i] = struct {
		result1 runtime.Volume
		result2 runtime.Worker
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePool) ReleaseWorker(arg1 lager.Logger, arg2 runtime.ContainerSpec, arg3 runtime.Worker, arg4 worker.PlacementStrategy) {
	fake.releaseWorkerMutex.Lock()
	fake.releaseWorkerArgsForCall = append(fake.releaseWorkerArgsForCall, struct {
		arg1 lager.Logger
		arg2 runtime.ContainerSpec
		arg3 runtime.Worker
		arg4 worker.PlacementStrategy
	}{arg1, arg2, arg3, arg4})
	stub := fake.ReleaseWorkerStub
	fake.recordInvocation("ReleaseWorker", []interface{}{arg1, arg2, arg3, arg4})
	fake.releaseWorkerMutex.Unlock()
	if stub != nil {
		fake.ReleaseWorkerStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakePool) ReleaseWorkerCallCount() int {
	fake.releaseWorkerMutex.RLock()
	defer fake.releaseWorkerMutex.RUnlock()
	return len(fake.releaseWorkerArgsForCall)
}

func (fake *FakePool) ReleaseWorkerCalls(stub func(lager.Logger, runtime.ContainerSpec, runtime.Worker, worker.PlacementStrategy)) {
	fake.releaseWorkerMutex.Lock()
	defer fake.releaseWorkerMutex.Unlock()
	fake.ReleaseWorkerStub = stub
}

func (fake *FakePool) ReleaseWorkerArgsForCall(i int) (lager.Logger, runtime.ContainerSpec, runtime.Worker, worker.PlacementStrategy) {
	fake.releaseWorkerMutex.RLock()
	defer fake.releaseWorkerMutex.RUnlock()
	argsForCall := fake.releaseWorkerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePool) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findOrSelectWorkerMutex.RLock()
	defer fake.findOrSelectWorkerMutex.RUnlock()
	fake.locateVolumeMutex.RLock()
	defer fake.locateVolumeMutex.RUnlock()
	fake.releaseWorkerMutex.RLock()
	defer fake.releaseWorkerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePool) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ exec.Pool = new(FakePool)
